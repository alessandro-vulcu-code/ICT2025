## Modularity

- Any realistic program is made of **multiple separate parts** (functions, classes, etc.).  
- A good implementation should be **modular**, keeping different concepts or abstractions separated.  
- There is **no specific C++ feature** for modularity, but it can be achieved using:
  - **Namespaces**
  - **Classes**
  - **Functions**

**Goals:**
- Keep abstractions distinct and isolated.  
- Allow access only through a **well-defined interface**.

---

## Need for Modularity

Example: two libraries defining classes with the same names → **name conflicts**.

```cpp
// a library for shapes
class Shape { /* ... */ };
class Line : public Shape { /* ... */ }; 
class Poly_line : public Shape { /* ... */ }; 
class Text : public Shape { /* ... */ }; 

// a library for text
class Glyph { /* ... */ }; 
class Word { /* ... */ }; 
class Line { /* ... */ }; 
class Text { /* ... */ }; 
```

If a program uses both libraries, it **will not compile** because classes `Line` and `Text` are **declared multiple times**.

---

## Namespace
- A **namespace** groups elements that logically belong together (e.g., a library’s code).
- Members of a namespace are all **in scope** within it.
- Namespaces are **open**, meaning new members can be added from different files.

```cpp
namespace TextLibrary {
    // a library for text
    class Line { /* ... */ }; 
    class Text { /* ... */ };
}; // end of namespace TextLibrary

```


## Access to namespace members

Namespaces allow logical grouping of related functionalities.  
There are different ways to access their members:

### 1. Explicit qualification
Access a member by prefixing it with the namespace name and the `::` operator.

```cpp
TextLibrary::Line line_object {};

// ::GlobalMemberName can be used to access
// members from the global namespace, which
// are otherwise shadowed by local variables
````

Example with a `using` declaration:

```cpp
using std::string;

string a_string {"hello"};
// instead of std::string a_string
```

---

### 2. Using directives

Bring _all_ names from a namespace into the current scope.  
⚠️ **Use them with care** – they can reintroduce name clashes that namespaces are meant to avoid.  
Do **not** place them in the global scope of a header file, as headers can be included anywhere.

```cpp
using namespace std;

string a_string {"hello"};
vector<string> vec {a_string};
// instead of std::string a_string
// and std::vector<std::string> vec
```

---

### 3. Argument-dependent lookup (ADL)
When calling a function, C++ searches in the namespace(s) associated with its argument types.

Rules:
- If the argument is a **class member**, first check the class, then its namespace.
- If the argument is a **namespace member**, check that namespace and its enclosing ones, up to the global.
- If the argument is a **built-in type** (`int`, `char`, `bool`, etc.), there are no associated namespaces.    

Useful especially for operators that rely on user-defined types.

---

## Modularization and Interfaces

A **program** is a combination of multiple independent parts.  
Each part may need access to functionalities provided by another.

To achieve modularity:
- Define **interfaces** as the only access point to a module’s functionality.
- Hide implementation details → **data-hiding principle** of data abstraction.

Interfaces can be implemented via:
- **Namespaces**, for logical grouping or library-level organization.
- **Classes**, in an object-oriented design.    

---
## Example of modular codebase
Example: a **TCP module** structured with multiple interfaces.
**TCP module** interacts with:
- **Congestion control interface**
- **Retransmissions interface**    
- **Header parsing interface**

Each interface hides its respective implementation:
- Congestion control algorithm
- Retransmission logic
- Header parsing implementation

✅ This design allows replacing parts (e.g., using different congestion control algorithms)  
without changing the overall TCP program code.

---

## ISO/OSI Stack – Summary

The **ISO/OSI model** (Open Systems Interconnection) is a conceptual framework that standardizes how data is transmitted across networks.  
It divides communication into **7 layers**, each responsible for a specific set of functions:

1. **Physical Layer** – Transmits raw bits over a medium (e.g., cables, radio).  
2. **Data Link Layer** – Handles framing, MAC addressing, and error detection between directly connected nodes.  
3. **Network Layer** – Manages logical addressing and routing of packets (e.g., IP).  
4. **Transport Layer** – Provides end-to-end communication, reliability, and flow control (e.g., TCP, UDP).  
5. **Session Layer** – Establishes, maintains, and terminates communication sessions.  
6. **Presentation Layer** – Translates data formats, encryption, and compression for compatibility.  
7. **Application Layer** – Interfaces directly with user applications (e.g., HTTP, FTP, DNS, SMTP).

Each layer communicates only with its adjacent layers, ensuring **modularity**, **interoperability**, and **abstraction** between hardware and software levels.
