## Classes

A **class** defines a *user-defined type* — a concrete representation of a concept.  
It lets the programmer **separate**:
- **Implementation details**, i.e.  
  - which variables represent the object,  
  - how they interact with each other.
- **Essential properties**, i.e.  
  - the *interface* used to manipulate objects of that type.

This separation enforces modularity and encapsulation.

---

## Classes basics

A class is a type composed of **members**, which can be:
- **Data members** – variables representing the state of the object.  
- **Member functions** – methods that define operations like initialization, copy, move, or cleanup.

Access specifiers:
- `public`: defines the **interface** available to users.  
- `private`: hides the **implementation details**.

---

### Access and operators

- Access members with:
  - `.` for objects
  - `->` for pointers to objects

- It’s possible to define custom operators (`+`, `-`, `[]`, etc.) for user-defined types.

- A class defines **invariants** — properties that must hold true from initialization to destruction.
	- e.g. weight of mouse (cannot be negative)

---

### Example

```cpp
class X {
private: // implementation details
    int m;

public: // public interface
    X(int i = 0) : m{i} {} // constructor

    int mf(int i) {
        int old = m;
        m = i;
        return old;
    }
};
````

This defines a simple class with:
- one private integer member `m`;
- a constructor initializing it;
- a member function `mf()` modifying it and returning the previous value.

## Classes basics

- Members of a class can be **data** (variables) or **functions** (methods).  
- **Data members** represent the internal *state* of the object.  
- **Member functions** perform operations like initialization, copy, move, and cleanup.  
- Access levels:
  - `public`: defines the *interface* for users.
  - `private`: hides *implementation details*.  
- This separation supports **encapsulation** and a clear distinction between *how* a class works and *how* it is used.

---

## Example of class

```cpp
class X {
private: 
    int m; // internal representation

public:
    X(int i = 0) : m{i} { }  // constructor

    int mf(int i) {          // member function
        int old = m; 
        m = i;
        return old;
    }
};
````

- The private section holds internal data (`m`), while the public section defines what users can access.
- The constructor initializes the object, and `mf()` modifies and returns the previous value of `m`.

---

## Example of class usage

```cpp
X var {7};  // variable of type X initialized to 7

int f(X var, X* ptr) {
    int x = var.mf(7);   // access via .
    int y = ptr->mf(9);  // access via ->
    int z = var.m;       // error: private member
}
```

Key points:
- `.` accesses members for objects.
- `->` accesses members through pointers.
- Direct access to private data (like `m`) is not allowed.

---
## Member functions

- **Member functions** are declared within a class and operate on its objects.    
- They can be:
    1. **Defined inside** the class → implicitly `inline`, used for small, stable functions.
    2. **Defined outside** the class → preferred for large or frequently updated functions.

**Inline functions** insert the function’s code at each call point, improving speed but potentially increasing binary size.

> Recall: “inline” means generating a copy of the code for every call, instead of one shared instance in memory.

## Example of member functions

```cpp
class X {
    int m;
public:
    // Inline member function
    int mf(int i) {
        int old = m;
        m = i;
        return old;
    }

    // Declaration only
    int amf(int j);
};

// Definition outside the class
int X::amf(int j) {
    return j + 2;
}
````

- Inline functions are defined directly in the class body.
- Non-inline functions are declared inside the class and defined outside using the `ClassName::functionName` syntax.
- This separation helps keep the header (.h) file lightweight and limits recompilation when the implementation changes.

---

## Access control
Access control defines which class members can be used externally.  
It helps **protect the object’s internal state** and **simplifies maintenance**.
- **public**: defines how other parts of the code can interact with the class.
- **private**: hides implementation details.
- **friend**: allows exceptions to access private members.

Advantages:
- Easier updates of internal implementation.
- Code using the class doesn’t need recompilation when internals change.
- Programmers only focus on the public interface.

---

## Example of public/private

```cpp
class X {
    int m; // private by default

private:
    int m2;
    int doSomething(double d);

public:
    X(int i = 0) : m{i} { } // constructor
};
```

- Members declared before any label are private by default.
- Use `public:` to explicitly define the external interface.
- Private data and functions can only be accessed internally or by friends.

---
## Example of friend classes

```cpp
class Y {
    friend class X;  // X can access Y’s private and public members
private:
    int v;
    int doSomething(double d);
public:
    Y(int i = 0) : v{i} { }
};
```

- A `friend` declaration grants another class or function access to private members.
- Useful when two classes are closely related and need to cooperate.
- Still maintains encapsulation for all other code.

---

## Structs and classes

- In C++, a `struct` is identical to a `class` except for **default access**:
  - In a `struct`, members are **public** by default.
  - In a `class`, members are **private** by default.
- General guidelines:
  - Use a **struct** for simple data containers (no encapsulation needed).
  - Use a **class** when enforcing **invariants** or hiding internal representation.

Advantages of using classes:
- They protect data by exposing only public methods.
- The developer can ensure **data integrity** through controlled access.

---

## Constructors

Constructors are **special member functions** used to initialize objects.

Key characteristics:
- Have the **same name** as the class.
- Have **no return type**.
- Can be **overloaded** with different parameter lists.
- Can use both `()` and `{}` initialization — `{}` is preferred for clarity and consistency.

Example:

```cpp
Date today = Date(22, 2, 1992);
Date tomorrow = Date{23, 2, 1992};
````

The use of constructors improves code readability and ensures objects are properly initialized.

---

## Explicit constructors

A constructor with a **single argument** can be used implicitly for **type conversion**.  
This can cause unexpected behavior, such as creating temporary objects unintentionally.

To prevent this, use the `explicit` keyword:

```cpp
class Date {
public:
    explicit Date(int d);
};

Date d = 15;  // ❌ Error: implicit conversion not allowed
Date d{15};   // ✅ OK: explicit initialization
```

---

## In-class initializers

It’s often useful to define **default values** directly inside the class.

```cpp
class Date {
    int d {22};
    int m {2};
    int y {1992};
public:
    Date(int, int, int);
    Date(int, int);
    Date(int);
    Date();
    Date(const char*);
};
```

Benefits:
- Provides **default initialization** without requiring multiple constructors.
- Simplifies maintenance and reduces repetitive code.
- Constructors can override these defaults when necessary.

---

## Mutability

An object’s data can be:
- **Mutable** → can change over time.  
- **Immutable (`const`)** → cannot be modified after initialization.

When a member function does not modify the object, it should be marked as `const`:

```cpp
int getDay() const;
````

Rules:
- `const` member functions can be called on both const and non-const objects.
- Non-const member functions cannot be called on const objects.
- `const` is part of the function’s type and must appear both in the declaration and definition.

---

## Logical constness

Sometimes, a logically constant function may need to modify internal data that does not affect the object’s logical state.  
Example: updating a cached string representation of an object.

```cpp
class Date {
    int d {22}; 
    int m {2}; 
    int y {1992};
    std::string string_cache;
    bool valid_cache;

public:
    std::string string_rep() const;
};
```

The cache (`string_cache`) may change internally, but the **logical value** of the date remains constant.

---

## Mutable members
To allow specific members to change within a `const` function, declare them `mutable`:

```cpp
class Date {
    int d {22}, m {2}, y {1992};
    mutable std::string string_cache;
    mutable bool valid_cache;

public:
    std::string string_rep() const;

private:
    void compute_cache_value() const;
};
```

```cpp
std::string Date::string_rep() const {
    if (!valid_cache) {
        compute_cache_value();  
        valid_cache = true;
    }
    return string_cache;
}
```

`mutable` allows controlled internal modifications while keeping the external interface logically constant.

---

## Mutability through indirection

Another approach is to store the changeable properties in a **separate object** referenced by a pointer.  
Since `const` does not propagate through pointers, the referenced object can still be modified.

```cpp
struct cache { bool valid; std::string rep; };

class Date {
    int d {22}, m {2}, y {1992};
    cache* date_cache;

public:
    std::string string_rep() const;
};

std::string Date::string_rep() const {
    if (!date_cache->valid) {
        // update cache
        date_cache->valid = true;
    }
    return date_cache->rep;
}
```

This technique maintains logical constness and avoids unnecessary mutable fields inside the main object.

---

## Self-reference

Inside a class, the keyword `this` is a pointer to the **current object**.

- For a non-const object → `this` has type `ClassName*`
- For a const object → `this` has type `const ClassName*`
- Most uses of `this` are **implicit**, meaning you can access members directly without writing `this->`.

`this` can also be useful to **chain operations** by returning a reference to the object itself.

Example:

```cpp
class Date {
    int d, m, y;

public:
    Date& add_year(int year) {
        y += year;
        return *this;
    }

    Date& add_month(int month) {
        m = (m + month) % 12;
        return *this;
    }
};

Date d {10, 5, 2003};
d.add_year(3).add_month(3);  // method chaining
````

This pattern allows multiple operations to be performed sequentially on the same object.

---

## Static members

A **static member** belongs to the class itself, not to any individual object.
Characteristics:
- There is **only one shared instance** per program.
- Must be **defined outside** the class before use.
- Static functions can be called without creating an object.

Example:

```cpp
class Date {
    int d, m, y;
    static Date default_date;

public:
    Date(int dd = 0, int mm = 0, int yy = 0);
    static void set_default(int dd, int mm, int yy);
};

// Definition of the static member
Date Date::default_date {16, 12, 1770};

// Definition of the static function
void Date::set_default(int d, int m, int y) {
    default_date = {d, m, y};
}
```

Static members are ideal for **shared configurations**, like default values or counters.

---

## Concrete classes

A **concrete class** defines a fully usable type, not just an interface.
- Objects of concrete classes can be:
    - Created on the stack or statically allocated.
    - Copied and moved.
    - Used as named variables without requiring pointers or inheritance.

Concrete classes emphasize **value semantics** (like structs), rather than pure object-oriented hierarchies.

Example difference:

|Concept|Description|
|---|---|
|**Concrete class**|Defines full implementation and data representation.|
|**Abstract class**|Defines only an interface (some methods declared but not defined).|

---

## Characteristics of concrete classes

Typically, they include:
- **Constructors** for initialization.
- **Const functions** to inspect the object’s state.
- **Non-const functions** to modify it.
- **Helper or error-reporting classes** if needed.
- **Copy/move functions** for efficient data handling.

Concrete classes are ideal for **small, efficient, user-defined types** that behave like fundamental data types (e.g., `Date`, `Point`, `Vector`).

They favor the **value-oriented** paradigm of C++, ensuring performance and clarity.

---

## Summary: Classes and Modularity in C++

- A **class** is the foundation of modular programming in C++.  
  It allows defining **custom types** that encapsulate both **data** and **behavior**.

- The core principles include:
  - **Encapsulation:** hiding implementation details behind a clean interface.  
  - **Data abstraction:** exposing only what’s necessary for using the class.  
  - **Information hiding:** preventing direct access to internal variables.  
  - **Reusability:** enabling the reuse of well-designed class components.

---

### Key Concepts Recap

| Concept | Description | Example |
|----------|--------------|---------|
| **Data members** | Represent object state. | `int m;` |
| **Member functions** | Define behavior and actions. | `int mf(int i);` |
| **Access specifiers** | Control visibility: `public`, `private`, `friend`. | `public: void f();` |
| **Constructors** | Initialize objects. | `Date(int d, int m, int y);` |
| **Explicit constructors** | Prevent unwanted implicit conversions. | `explicit Date(int d);` |
| **In-class initializers** | Provide default values for members. | `int y {1992};` |
| **Const-correctness** | Mark methods that don’t modify the object. | `int getDay() const;` |
| **Mutable** | Allow modification inside const methods. | `mutable string cache;` |
| **this pointer** | Reference to the current object. | `return *this;` |
| **Static members** | Shared data/functions across all instances. | `static int count;` |

---

### Concrete Classes

- Represent *self-contained, value-like objects* (e.g., `Date`, `Vector`, `Complex`).
- Support direct manipulation without inheritance or pointers.
- Benefit from compiler optimizations and simpler memory management.

**They provide:**
- Predictable performance.  
- Clear ownership of data.  
- Straightforward use in both stack and heap contexts.

---

### Practical Takeaways

- Use **classes** to model real-world concepts and ensure safe, organized code.  
- Keep **interfaces minimal and stable**, **implementations hidden**.  
- Prefer **value semantics** when possible — it makes code simpler and safer.  
- Use **constructors and const-correctness** to guarantee valid and immutable states.  
- Apply **namespaces** to separate logic and avoid name conflicts between libraries.

This structure — combining **classes**, **namespaces**, and **interfaces** — is the basis of **modern modular C++ programming**, supporting scalability, reusability, and maintainability.

