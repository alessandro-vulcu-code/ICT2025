## Functions

- Break the code into simple, meaningful chunks and name them.

1. The code is more comprehensible – this helps maintainability.
2. The code can be reused.
3. It is possible to compose multiple functions to obtain combined results, e.g., `f(g())`.
4. It helps document dependencies.
5. It saves from error-prone control structures.

- There is little or no cost in performance in using functions — with some precautions, as we will discuss later in this lesson.

---

## Function declarations

A function declaration has multiple parts:

- **name (required)**
- **argument list (required)**  
    specify the number and type of arguments.  
    The name for each argument is optional for the declaration, required for the definition.
- **return type (required)**  
    it may be `void`, if the function does not return a value.  
    It can be specified as a **prefix** or **suffix**.

```cpp
int sqrt(int number); 

auto sqrt(int number) -> int; 
```

**argument list – name – prefix return type – postfix return type (with `auto` in the prefix)**

This is useful for templates, where the type of return is not known _a priori_ but depends on the type of the arguments.


A function declaration has multiple parts:

- **inline (optional)**  
    keyword that suggests to the compiler to generate new code for every function call, instead of a single code in memory that is pointed to by every call.  
    This enables an optimization in terms of execution speed.  
    The compiler is not required to respect the `inline` keyword.
- **constexpr (optional)**  
    specifies that the function can be evaluated at compile time.  
    Simple, no loops, no side effects (e.g., no changes to global variables).
- **noexcept (optional)**  
    specifies that a function cannot throw an exception.
- **static (optional)**  
    for linkage (more on this in following lessons).
- other keywords for functions defined in classes (member functions).

---

## Returning values

- `void` to specify that no value is returned.
- **Prefix vs postfix** return (`++counter vs counter++`)
- The point and value of the return is specified by a `return` statement.
- There can be more than one `return` in a function, and the function returns when executing the first of them in the logic flow.

**Return with a copy:**

- A variable of the returned type is initialized and then returned.
- The memory is reused after the function returns, so **never return a pointer or a reference to a local non-static variable**.
    

```cpp
int f(int a) {
    if (a == 0) {
        return 1;
    }
    int b = a * 10;
    return b;
}
```

**5 ways to exit a function:**

1. `return`
2. _“falling off at the end”_, i.e., reaching the end of the function body (only for `void` return type)
3. By throwing an exception which is not caught locally
4. Terminate after an exception which is not caught locally in a `noexcept` function
5. Invoke a system function that does not return (`exit()`)

---

## Function definition

- A function that is called must be defined **once**.
- The definition presents the **body** of the function.

```cpp
int f(int a) 
{
    if (a == 0) {
        return 1;
    }
    int b = a * 10;
    return b;
}
```

---

## Local and static variables

- A **local variable** is a name defined in a function.
- Every call to the function performs a new initialization of each local variable. 
- A **static variable** is different:
    - Only the first call to the function creates the object.
    - It enables the sharing of a variable across function calls.
    - No need to use global variables.
    - This can be dangerous, and static variables in functions should be used with care or avoided.

---

## Argument passing

- The suffix `()` (call or application operator) contains a list of arguments.    
- When a function is called, **memory is set aside** for _formal arguments_ (or _parameters_), i.e., those specified in the function declaration.
- Each parameter is then initialized with the _actual arguments_ (those passed by the caller).

The compiler:
- checks the type,
- performs standard or user-defined type conversions.

---

## Pass by value

- When a variable is **passed by value** from the caller to the called function, the **value of the variable is copied** into a new variable, which is independent from the first.    
- The function does **not modify** the variable that is passed to it; it copies the value into a new one and uses that.

```cpp
void increment(int a) 
{
    ++a;
    std::cout << a << std::endl; // when called
    // as below, this will print 3
}

int a = 2;
increment(a);
std::cout << a << std::endl; // this prints 2 – the
// variable a outside of the function is not modified
```

---

## Pass by reference

- When a variable is **passed by reference** from the caller to the called function, the **value is not copied** into a new variable.
- The function **directly modifies** the variable that is passed to it (unless it is declared `const`).

```cpp
void increment(int& a) 
{
    ++a;
    std::cout << a << std::endl; // when called
    // as below, this will print 3
}

int a = 2;
increment(a);
std::cout << a << std::endl; // this prints 3 – the
// variable a of the caller has been modified by the function
```

---
## Pass by reference (good practice)

- It is **not good practice** to modify arguments passed by reference.
    - It is better to **explicitly return** the modified value — this makes the code clearer and easier to maintain.
- It can be more efficient to avoid the copy (with pass-by-value) of large objects:
    - use **const references** for large objects which do not need to be copied and/or modified in the function itself.

```cpp
void f(const LargeType& a);
```

- **Pass by const lvalue reference**
- **Pass by rvalue reference** (e.g., to bind to a temporary object)

```cpp
void f(const LargeType& a);
void f(LargeType&& a);

void f(std::vector<int>&);        // (non-const) lvalue ref argument 
void f(const std::vector<int>&);  // const lvalue ref argument
void f(std::vector<int>&&);       // rvalue reference argument

void g(std::vector<int>& vi, const std::vector<int>& vci) 
{ 
    f(vi);                // call f(vector<int>&) 
    f(vci);               // call f(const vector<int>&) 
    f(std::vector<int>{1,2,3,4}); // call f(vector<int>&&) 
}
```

---
## Guidelines (from C++PL)

Follow these guidelines in order:

1. Pass-by-value for small objects.
    
2. Pass-by-const-lvalue-reference for large objects not to be modified.
    
3. Return a result with `return` instead of modifying the argument.
    
4. Pass-by-rvalue-reference for move and forward (more on this in future lessons).
5. 
6. Pass a pointer if the “no object” case can be dealt with, and represent “no object” with a `nullptr` (portable).
    
7. Pass-by-lvalue-reference only as a last option.
    - If for some reason the argument needs to be modified by the function, the usage of a pointer can be clearer and easier to understand.

---

## Array arguments

- C++ arrays are **not passed by value**, but by **pointer**.
    
- When an array is specified as argument, it **always decays into a pointer**.
    
    - Historical reasons inherited from C – in the 1970s, machine memory was limited, and it was more efficient to pass a pointer to the array than copy the entire array.
        
- The **information on the size is lost** and not implicitly available to the function.
    
- This is another good reason to **avoid using arrays**, and prefer `std::vector` or other standard library containers.
    

```cpp
// these three declarations are equivalent and declare the same function
void f(int* p);
void f(int[] a);
void f(int b[1000]);
```


- The information on the size is lost — and not implicitly available to the function.

**Workarounds:**

1. Explicitly pass the size as argument.
    
2. Pass a reference type to the array.

```cpp
void f(int* p, size_t size_of_the_array);
void f(int (&r)[1000]);
```

The size is compulsory (part of the type), thus the flexibility of this call is limited.

---

## List arguments

A `{}`-delimited list can be an actual argument to a parameter of type:

1. `std::initializer_list<T>`
    
2. Reference to array of type `T`
    
3. Type that can be initialized with the values in the list
    

Only if all the values in the list can be implicitly cast to `T`.

```cpp
template<class T>
void f(std::initializer_list<T>); 

template<class T, int N> 
void f2(T (&r)[N]); 

void g() { 
    f({1,2,3,4});   // T is int + initializer_list has size 4
    f2({1});        // T is int, N is 1
}
```


If there is ambiguity, `std::initializer_list<T>` has the precedence – this may cause errors.

```cpp
template<class T>
void f(std::initializer_list<T>); 

template<class T, int N> 
void f(T (&r)[N]); 

struct S { int a; std::string s; };
void f(S); 

void g() { 
    f({1,2,3,4});    // T is int + initializer_list has size 4 
    f({1,"MKS"});    // calls f(S), not all the values can be 
                     // implicitly cast to int
    f({1});          // T is int + initializer_list has size 1
}
```

---

## Unspecified number of arguments

There are different ways to deal with an **unknown number of arguments**:

1. **Variadic templates** (arbitrary number of arbitrary types)  
    _(more on this when we study templates)_
    
2. Use `std::initializer_list<T>` (arbitrary number of the same type)
    
3. **Ellipsis (`...`)** (arbitrary number of arbitrary types)
    
    - Not type-safe (the compiler does not know the types a priori).
        
    - Some user-defined types may not work.
        
    - This may cause errors: use it only if 1 and 2 are not an option.
        

✅ 1 and 2 are type-safe.

---

## Default arguments

- Sometimes it is useful to have **default values** for some arguments.
    
- They can be provided for **trailing arguments only**.

```cpp
int f(int a, int b = 0, char* c = nullptr); // OK
int g(int = 0, int = 0, char*);             // error 
int h(int = 0, int, char* = nullptr);       // error
```

---

## Overloaded functions

- Different functions usually have different names.
    
- It can be convenient to **name in the same way** different functions that perform the same task on different types.
    

**Overloading**  
(already used for operators, e.g., `+`)

```cpp
void print(int);           // print an int
void print(const char*);   // print a C-style string

// using different names leads to more complex code
// and makes it more difficult to maintain
void print_int(int);
void print_char(const char*);
```

---

## Automatic overload resolution

- The compiler compares the types of **actual** and **formal** arguments — it uses the function that provides the best match, with rules in the following order:
    

1. **Exact match** (no or trivial conversions – array to pointer or vice versa, `T` to `const T`)
    
2. **Match using promotions** (to integral types with larger ranges, or to floating-point types with higher precision)
    
3. **Match using standard conversions** (e.g., `int` → `double`)
    
4. **Match using user-defined conversions**
    
5. **Match using ellipsis** (...), which means I can pass an undefined number of variables with unspecified type

- If two different matches are identified at the highest level of a match, the compiler gives an **error**.
    
- The **return type** is not considered for resolution.
    
- Functions in **different scopes** are not overloaded — the compiler knows exactly which one should be used, without the need to resolve.

---

## Pre and post conditions

- Sometimes there are **expectations** on the arguments and return values (e.g., they are within a certain interval).
    
- The compiler only checks the **type**.
    

**Logical criteria:**

- Those that hold for arguments are called **preconditions**.
    
- Those that hold for return values are **postconditions**.
    

It is not always possible to enforce them — there is a **trade-off** between checking and performance.  
Sometimes there are **no meaningful checks** (especially on return types).

---

## Pre and post conditions – good practices

- Write good documentation of your functions by specifying **pre and post conditions**.  
    **AND/OR**
    
- Write code that deals with pre/post conditions using different options:
    

1. Make sure every input has a valid result (no preconditions).
    
2. Assume that the preconditions hold (rely on the caller, trading possible crashes for performance).
    
3. Check and throw an exception if preconditions are not met.
    
4. Check and terminate if preconditions are not met.

---

## Pointer to function

- The code for a function is stored in memory.
    
- It is possible to get its address in a **pointer**.
    
- It can be used only to **call the function**.
    

```cpp
void error(int s) {
    // implementation
}

void (*efct)(int); // pointer to function that takes
                   // int as argument and does not return anything

void f() {
    efct = error;   // same as efct = &error
    efct(10);       // same as (*efct)(10), dereferencing is optional
}
```

---

## Pointer to function (continued)

- It is possible to cast function pointers to other function pointer types,  
    but this must be avoided — **bad practice** that can lead to errors.
    
- They are used to **parametrize C-style code**.
    

```cpp
using CFT = int(*)(const void*, const void*);

// function that sorts elements independently of the type of base,
// using cmp for comparisons
ssort(void* base, int size, CFT cmp);

// cmp is a pointer to a specific implementation 
// of a function that compares objects of the actual type of base

int cmp1(const void* p, const void* q) // Compare int 
{ 
    return *(static_cast<const int*>(p)) - *(static_cast<const int*>(q)); 
} 
```

---

## Pointer to function (modern C++ alternative)

- They are used to parametrize C-style code.
    
- This is **not recommended** in modern C++; use:
    

```cpp
using CFT = int(*)(const void*, const void*);

// function that sorts elements independently on the
// type of base, using cmp for comparisons  
ssort(void* base, int size, CFT cmp);

std::vector<int> v {1, 3, 2, 4};
std::sort(
    v.begin(), v.end(), 
    [](const int n1, const int n2) { return n1 < n2; }
);
```

**Iterators** are used to specify the range,  
and a **lambda function** defines the comparison rule.

---

## Macros

- Inherited from **C**.
    
- Few meaningful uses in **C++**.
    
- They can be used for **conditional compilation**.
    

```cpp
#define MAX_HEIGHT 720

void f(int a) {
    int b = a + MAX_HEIGHT; 
}
```

- A dumb preprocessor will simply replace `MAX_HEIGHT` with what is defined in the macro (`720`).
    
- If you want to use `MAX_HEIGHT` as a name for a member variable (don’t do it),  the preprocessor will replace it with `720` and the code will not compile.
    

👉 For this scenario, use a `constexpr` or a `const`.

---

## Conditional compilation

- Macros can be used for **conditional compilation**.

```cpp
int a = 10;
#ifdef IDENTIFIER
// some code
#endif // IDENTIFIER (good practice to comment)
a -= 2;
```

Unless `IDENTIFIER` is defined somewhere before this code  
with `#define IDENTIFIER`,  the code between `#ifdef` and `#endif` will **not** be compiled.

---

## Include guards

- A header file (`.h`) with declarations and definitions may be included in multiple files.  
    For example, `#include <iostream>` is included in every file that wants to use `std::cout`.
    
- Errors can occur if the compiler tries to compile the same header multiple times.
    

```cpp
#ifndef STRUCTS_ENUM_TEST
#define STRUCTS_ENUM_TEST

// code of the header 

#endif /* STRUCTS_ENUM_TEST */
```

- The first time the header is compiled, `STRUCTS_ENUM_TEST` is not defined — condition is **true**, and it becomes defined.
    
- The next times, `STRUCTS_ENUM_TEST` is already defined — condition is **false**, so the file is not recompiled.