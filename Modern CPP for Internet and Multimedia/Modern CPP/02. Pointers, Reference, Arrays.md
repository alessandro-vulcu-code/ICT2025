## 1. Pointers

### Definition:

- **T* is a pointer to type T.**
    
- A pointer stores the address of an object of type T.
    

### Example:

```c++
char c = 'a';
char* p = &c;  // p stores the address of c

char c2 = *p;  // Dereferencing: c2 is 'a'
```

## 2. Void Pointer

### Definition:

- A **void pointer** is used when you don't know the data type, but you have limited operations you can perform.
    
- You **cannot dereference** a void pointer.
    

### Example:

```c++
int a = 1;
int* p1 = &a;
void* p2 = &a;

// ERROR: Cannot dereference a void pointer
std::cout << *p2 << " " << a << std::endl;  
```

- This results in a compiler error because the type is unknown.
    

## 3. Null Pointer

### Definition:

- A **null pointer** is a pointer that does not point to any object.
    
- It is commonly used for **null checks**.
    

### Example:

```c++
void f(int* p){
    std::cout << *p << std::endl;
}

int main(){
    int a = 1;
    int* p1 = &a;
    f(p1);
    
    p1 = nullptr;  // Set p1 to null
    f(p1);         // Segmentation fault (core dump)
}
```

## 4. Pointers and Ownership

### Definition:

- A pointer **can access and modify** data, but it **does not own** the memory it points to unless explicitly allocated.
    

### Example:

```c++
int a = 1;      // a owns the memory where 1 is stored
int* p1 = &a;   // p1 is not the owner

int* p2 = new int {2};  // p2 owns the memory
delete p2;               // Free memory before p2 goes out of scope
```

## 5. Pointers and Const

### Definition:

- A **const pointer** means the pointer itself cannot be changed to point to another memory address.
    
- A **pointer to const** means the object being pointed to cannot be modified.
    

### Examples:

```c++
const char* p = "unipd";        // p is a pointer, but the object it points to is constant
const char* const p2 = "unipd"; // Both the pointer and the object are constant
```

## 6. Arrays

### Definition:

- An **array** is a sequence of objects of type T, stored contiguously in memory.
    
- Arrays can be **statically allocated**, on the **stack**, or in the **heap**.
    

### Characteristics:

- Accessed with the `[]` operator, with valid indices from `0` to `size - 1`.
    
- **Cannot be copied** directly (arrays are not assignable).
    

## 7. String Literals

### Definition:

- A **string literal** is a sequence of characters terminated by `\0`.
    
- String literals are **statically allocated** in memory.
    

### Example:

```c++
const char* str = "Hello, World";  // Automatically null-terminated

const char upd [] = "unipd";

std::cout << size(upd) << std::endl;  // 6 because is unipd\0

```


We can access arrays through pointers

```c++
int v[] = {1,2,3};
int* p1 = v;
int* p2 = &v[2] + 1;
int *p2 = &v[2];
p2++;

for(int] p1 = v; p1 < p2; p1++)
	// print array, 1,2,3

```

## Operation on pointers

- Increment, decrement, subtract (range, how many elements.)

## Reference

```c++
int a = 1;
int& r = a;
r++
std::out << r << std::endl

//out is 2 because r and a are the same thing with different names

```


Yes, your definition is correct.

Here's a translation in English:

---
### Lvalue and Rvalue

In programming, an **"lvalue"** is an expression that represents an object located at a specific, identifiable memory location, while an **"rvalue"** is an expression whose value can be used as the value of another expression but may not have a well-defined memory location.

```cpp
int x = 42; // 'x' is an lvalue because it has an identifiable memory location.

int y = x + 5; // 'x + 5' is an rvalue, as it only represents the resulting value of the operation, not a specific memory location.
```

In this example, `x` is an lvalue because it has a memory location, while `x + 5` is an rvalue because it only represents the result of the operation without a specific memory location.


move: converts rvalue to lvalue

struct enum va be diocan
struct are basically the same as classes