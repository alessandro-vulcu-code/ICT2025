# Keyless Cars Security - CPS and IoT Security

## Physical Keys
- Initially, cars used ignition systems that required turning a physical key.
- The key would send a signal to start the ignition system and ignite the fuel vapor.
- This system had a significant flaw: an attacker with physical access to the car could replicate the signal.

## From Physical to Cyber Keys
- The immobilizer was the first solution to incorporate a cyber-component.
- It featured a small chip embedded in the car key.
- When inserted into the ignition, the chip emitted a unique code, which the car’s antenna received.
- If the code matched the car’s expected code, the ignition would start.

## Immobilizer
![[Pasted image 20251009133243.png]]

## Immobilizer Flaws
- Immobilizers prevent hotwiring and lockpicking, but they transmit the same code each time.
- An attacker could use eavesdropping equipment to record the code and later replay it to steal the car.
- This flaw was easily exploited using devices called code grabbers.

![[Pasted image 20251009133549.png]]

## Digital Signature Transponder
- Some car brands (Ford, Toyota, Nissan) use Digital Signature Transponders (DSTs).
- The DST is an RFID chip that uses encryption and a 40-bit secret key to secure communication.
- The car and the DST share a copy of the private key, ensuring secure communication.
![[Pasted image 20251009133842.png]]

![[Pasted image 20251009133927.png]]

## Cloning Attack
- The DST system prevents simple replay attacks, but the 40-bit key length is vulnerable.
- An attacker can record a challenge and response from the car, then try all possible key combinations.
- With FPGA hardware, this attack can be completed in a few hours, gaining access to the car.

## DST+ - Improved Solution
- DST+ improves DST by adding a Mutual Authentication Key (MAK).
- Both the car and DST+ share a key (K) and MAK for better security.
- If the challenge is incorrect, the DST+ will not respond, preventing replay attacks.

![[Pasted image 20251009134642.png]]

## Further Protection Measures - PKES
- Passive Keyless Entry Systems (PKES) work without user interaction.
- PKES uses RFID to check if the key is inside, outside, or near the car.
- The car starts the engine only if the key is within close proximity (inside the car).

## Different Threat Model
- In this model, the attacker does not have direct access to the key.
- Relay attacks exploit wireless communications between the key and the car, bypassing the challenge-response protocol.

## Relaying Signals
- A relay attack involves a man-in-the-middle attack, where a non-legitimate device relays communication between the key and car.
- The attacker does not need to modify or interpret the signals, just amplify and retransmit them.

![[Pasted image 20251009135053.png]]

## Advantage of Relay
- In a relay attack, the attacker only manipulates the physical layer by demodulating and amplifying signals.
- The delay introduced must be within the range accepted by the car's system to be effective.

## Relay over Cable
- The attack uses two loop antennas connected via a cable to relay low-frequency signals.
- This method is basic and may raise suspicion due to the visible cable.

![[Pasted image 20251009135613.png]]

## Relay over the Air
- To avoid detection, the cable is replaced by a wireless relay system.
- The emitter captures the low-frequency signal, upconverts it, amplifies it, and transmits it over the air. The receiver downconverts and amplifies it again.

![[Pasted image 20251009135814.png]]
## Results
- Successful relay attacks can unlock and start a car by relaying signals between the car's key and the vehicle.
- This type of attack exploits vulnerabilities in the car's wireless communication protocol.

![[Pasted image 20251009135912.png]]

## Possible Countermeasure: Distance Bounding
- Distance bounding protocols measure the physical distance between two entities.
- Using rapid exchanges of messages, distance can be estimated by measuring the communication round trip time.
- This prevents relay attacks by ensuring the key and car are within a valid proximity.

---

### Mafia Fraud Attack

In the context of distance bounding protocols, a **mafia fraud attack** occurs when the attacker sets up two devices: one near the verifier and another near the legitimate prover. Both the prover and verifier are unaware of the attacker's presence. The attacker manipulates the communication between the two to cheat on the signal the verifier expects.

### Possible Countermeasure

To prevent mafia fraud, **distance bounding** protocols measure the upper bound of the prover-verifier distance by exchanging messages rapidly. The verifier sends a challenge to the prover, and upon receiving a response, the verifier measures the round-trip time (RTT) to estimate the distance between the prover and the verifier.

### Distance Bounding Protocols

Distance bounding protocols were introduced in 1993 to prevent relay attacks. These protocols use RTT to estimate the distance, ensuring that the prover is within a certain proximity to the verifier. If the prover-verifier distance is `d`, and RTT is `T`, then the distance `d` is less than `0.5 * T * c`, where `c` is the transmission speed.

---

### A Famous Example

In the distance bounding protocol, a prover and verifier execute cryptographic operations to verify the prover's proximity. The verifier generates random numbers and sends them to the prover, who responds by generating a signature based on the received challenge.

### A Famous Example: Brands and Chaum (BC)

In this example, the verifier generates random bits and the prover responds with their own random bits. The verifier then measures the RTT for each round, ensuring that the distance is within the expected range. The prover must also send a valid signature for the challenge to be accepted.

### BC Protocol v.2

In version 2 of the BC protocol, additional security measures are implemented by having the prover commit to a random bit string. The verifier then generates bits, and the prover must respond quickly to ensure that the response is valid. The distance is then calculated based on the response times.

![[Pasted image 20251015150140.png]]

---

### Mafia Fraud in BC

In the **Mafia fraud attack** within the **BC protocol**, the attacker sets up a **time-gaining relay**, creating a link that delivers the challenge or response bits in advance. This enables the attacker to manipulate the system and gain access, even though the bits are unguessable and cannot travel faster than the speed of light. 

- The attacker’s goal is to exploit timing to manipulate the authentication process.
- By creating a time-gaining relay, the attacker can control the sequence and potentially bypass security measures.

- To execute a Mafia fraud attack, the adversary should create a time-gaining relay, a link that delivers in advance the challenge or response bits.
- However:
  - Bits are unguessable (depending on the RNG)
  - Cannot travel quicker than light
- What is the probability of success of time-gaining Mafia fraud?
  - Guess a bit = ½
  - Generation is independent → ½^k over k bits
  - For k = 128 → P(success) = 3 * 10^-39

## Is There a Standard?

- Many manufacturers do not use standard mechanisms for protecting against relay attacks.
- However, viable options are available:
  - BLE for initial handshake & cryptographic exchange
  - IEEE 802.15.4z (High-Repetition Pulse Ultra Wideband) for ranging
  - Combined with Car Connectivity Consortium (CCC) Digital Key for vehicle access flow
  - Cryptographic Scrambled Timestamp Sequences (STS), two-way ranging, multiple anchors around the vehicle

---

### CCC and Digital Key

- **Car Connectivity Consortium (CCC)** standardizes how vehicles can automatically unlock as the driver approaches.
- **Digital Key standard** calculates the distance using UWB (Ultra-Wideband) to ensure the user is within a few meters of the car.
- Bluetooth Low Energy (BLE) is used for high-level communication between the vehicle and the driver’s smartphone.

---

### Setup
![[Pasted image 20251015151234.png]]
- **UWB Digital Key receiver transmitter** - Digital Key
- **UWB Digital Key receiver transmitter** - Radar
- **Shark fin with UWB** - and other functions
- **Connected Car Consortium** - Digital Key

Two UWB measurements provide a more accurate distance result.

Can control using:
- Smartphone
- Key-fob
- Smartwatch

---

- Initially. we had a simple BLE link to create a link between the car and the user's smartphone;
- This methods had shortcomings such as the relay attack;
- The addition of the UWB element into the mix tried to solve this problem;
- In addition, thanks to the secure exchange og the Digital Key we archieve secure ranging;
- A more robust implementation envisions using more than a single UWB transceiver
- As the driver approaches, the vehicle will unlock the passenger’s door, driver’s door or trunk depending on the driver’s distance and direction

---

### UWB Ranging

- **Modulated pulses** are sent in an impulse response stream.
- Each frame consists of thousands of pulses sent in a specific code pattern.
- The received signal histogram represents the **channel impulse response**.
- Timestamps are estimated from this to calculate the **range**.

**UWB Histogram Example**
- The signal strength includes the first and second peak received.
- The echo from the ground is captured.
- Each application’s area provides a unique response.
![[Pasted image 20251015152144.png]]

---

### Autocorrelation Measurements

- Known sequences must be embedded in the transmitted signal for autocorrelation measurements.
- In **UWB (802.15.4 and 802.15.4z)**, we have:
  - **SYNC/preamble field** at the beginning of the UWB packet.
  - **Start of Frame delimiter**.
  - **Scrambled Timestamp Sequence** (in 802.15.4z) to prevent fake ranging results. It is a pseudo-random pulse sequence generated based on **AES-128**.

### STS Generation

- **Inputs/keys/seeds required**:
  - A 128-bit **STS key** (`phyRrpWwbStsKey`).
  - A value **V** including a counter and upper bits.

- The **Deterministic Random Bit Generator (DRBG)** uses **AES in counter mode** to encrypt the counter+seed.

- Each 128-bit **AES output** becomes part of the **STS**:
  - **bit=0** → positive polarity pulse.
  - **bit=1** → negative polarity pulse.

- **STS arrangement**:
  - STS is divided into segments, with each segment having active chips separated by silent intervals.

- The receiver, knowing the **STS key** and **seed**, can reconstruct the same STS locally and correlate the correct segment with the expected one.

---

![[Pasted image 20251015152324.png]]
**Diagram Overview**:
- The process begins with inputs like the **128-bit STS key** and **counter**.
- AES-128 is used to generate **128-bit pseudo-random numbers**, which are used to form the 128 pulses of the STS.

### ToA Estimation

- Given the **known sequence** and **received signal**, cross-correlation is performed as:
  
  $$ R_{rx}(τ) = \int_{−∞}^{∞} r(t) s(t−τ) dt $$

- The **ToA** (Time of Arrival) is defined as the value where cross-correlation is maximized:

  $$ \hat{τ} = arg \max_{τ} R_{rx}(τ) $$

- Since everything is discrete, the equation becomes:

  $$ R_{rx}[n] = \sum_{k=0}^{N−1} r[k] s[k−n] $$

- And hence, **ToA** becomes:

  $$ \hat{τ} = arg \max_{n} R_{rx}[n], \hat{τ} = \hat{n} \cdot T_s $$

---

### Two-Way Ranging

- The standard envisions different **UWB modalities**, but **Double-Sided Two-Way Ranging (TWR)** is the preferred method to determine the distance between two UWB transceivers.
  
- Each transmitter takes turns transmitting **STS**, extracting the **time of transmission** and **reception**, and securely communicating this over the data link with **evolving secure keys**.

- After receiving the information twice, the **Time of Flight (ToF)** can be calculated and translated into **distance** without relying on perfectly synchronized clocks.

---

### Remote Keyless Entry and Start

- **Remote Keyless Entry (RKE)** relies on unidirectional data transmission from the remote control (car key) to the vehicle.
- The key is active, and upon pressing a button, it transmits signals in one of the bands: **315 MHz**, **433 MHz**, or **868 MHz** (depending on the country).
- RKE systems allow users to lock and unlock the vehicle comfortably from a distance and can also be used to switch the anti-theft alarm on and off.

---

### Remote Keyless Entry and Start - Early Generations

- The first generation of RKE used **no cryptography**, solely relying on a **fix-code signal**.
- However, this made **replay attacks** very easy.
  
### Rolling Code Systems

- The next generation of RKE uses **rolling code systems**.
- **Rolling codes** use cryptography and a counter value that increases with each button press.
- They use a combination of the counter and other signals as input to the **cypher**, and the car checks this information to validate the signal.

---

### Rolling Codes
![[Pasted image 20251015153804.png]]
- The rolling code message structure consists of:
  - **Preamble**: Regular sequence of 0s and 1s.
  - **Start**: The beginning of the data transmission.
  - **Payload**: The cryptographic data payload, including:
    - **Unique Identifier (UID)**
    - **Rolling counter value**
    - **Pressed button**
  - **Checksum**: Ensures data integrity.

---

### Authentication in Rolling Codes

- **Implicit Authentication**: 
  - The entire payload is **symmetrically encrypted**.
  - The receiver checks the **UID** and if the **counter** is within its validity window.

- **Explicit Authentication**: 
  - The sender computes a **message authentication code (MAC)** over the data payload and appends it to the packet.

---

### One of the Many Implementations

- The **grey part** in the message is the encrypted portion.
- The **payload** is encrypted using a proprietary block cipher.
- A commonly used cipher is **AUT64**, found in many cars from the Volkswagen group.

**Message Structure**:
- **Start**
- **UID** (Unique Identifier)
- **Counter**
- **Button** (pressed button)

![[Pasted image 20251015154333.png]]

---

### Synchronization and Pairing

- Both the **car** and **remote** are synchronized to an initial number (e.g., **PRNG seed**), enabling the remote to be paired.
- This process typically relies on some configuration, such as pressing a button or using a **master key**.

**Example of a Pairing Process**:  
The image shows the **programming button** used for pairing the remote, along with an **LED indicator** for the process.

![[Pasted image 20251015154405.png]]


- Once the **remote** and **car** are synchronized, they use an algorithm to choose an initial number **x** and transform it to the next number in the sequence (**x+1**).
- The following key press will take the result of the previous keypress as input.
- If a single remote press is intercepted, there is no way to determine the next code expected by the receiver due to encryption.

---

### Keypress Management

- Devices not only store the next code to be transmitted but a significant number of them (e.g., **255** codes).
- This is essential to ensure the process works even with **erroneous keypresses** that increase the counter only on the key side.
- As soon as a valid keypress is received, the list is updated to be **x iterations** from that keypress.
- However, if the number of keypresses is too large, there is no way to catch up on synchronization.

---

### One of the Many Implementations

- Few well-known manufacturers provide **rolling code-based RKE**.
- **Microchip Technology** provides **Classic**, **Advances**, and **Ultimate KeeLoq** with publicly available documentation and data sheets.
- Companies like **NXP**, **Omron**, and **TI** provide proprietary solutions.
- Let's take a deeper look at **KeeLoq** (which is open source), as the idea behind rolling codes is always the same.

---

### KeeLoq

- **Uniqueness** in key fob transmission is achieved by incrementing a **16-byte counter** in the key fob (and vehicle upon reception).
- A **button press** is valid if the counters at each side are in sync.
  - If the difference between the key and car counter is small (**< 16**), counter synchronization takes place immediately with the first button press without additional steps.
- **Sync** means that the receiver unit in the vehicle invalidates all non-received codes before the one present in the last keyfob signal.

---

### KeeLoq (Continued)

- If the difference between counters is **greater than 16** and **less than 2^15**, the receiver temporarily stores the counter and waits for a subsequent transmission (the same button must be pressed again).
- If the subsequent transmission has the **previous counter +1**, the receiver resynchronizes on the last transmission received.
- If any of the above fails, the key fob signal received by the vehicle is **discarded**.

---

### Missing Link Attack

- As an **attacker**, the goal is to prevent the receiver from receiving any of the **radio transmissions** from the remote.
- To achieve this, we can **jam** the communication between the key and the car.
- This technique is often used by thieves to prevent drivers from closing their cars in parking lots.
- Notice that we can use a **transmitter** on a similar frequency, as receivers have **large windows** for detecting signals (to account for **temperature changes** and **flat batteries**).

---

### RollJam Attack

- **Remote jamming** works, but the person walking away from the car may notice that it did not lock (no noise).
- The goal is to develop a technique that is **indistinguishable** from the standard interaction between the car and the owner.
- This is achieved by integrating **jamming** and **replay attack** in the **RollJam** attack.
- The technique involves:
  - **Jamming the signal**, capturing it, and then replaying it as a legitimate communication between the key and the car.

---

**RollJam Attack - Visualization**

- **Listen Window**: The window where the attacker listens for the signal.
- **Jammer**: The device used to jam the communication.
- **Receive Window**: The window where the car receives the signal from the key.

The image shows the interaction of the jammer with the car's communication window.
![[Pasted image 20251015160249.png]]

- While the signal is **jammed**, we can use the same window to capture the **first legitimate message** that the key sends to the car.
- This is possible because the **jamming** is not on the exact same frequency as the signal.
- When someone cannot get a remote to work, the instinctive reaction is to press the remote again.
- As soon as this happens, we can capture a **second** (successive) instance of a legitimate transmission.
- We can then **replay the two signals** in the captured order.

---

### RollJam Attack - Example
![[Pasted image 20251016124054.png]]

- **Attacker** captures the first transmission (`Val 1`) and jams it.
- The **victim** presses the remote again, sending the second transmission (`Val 2`).
- The attacker captures the second transmission.
- The attacker then replays the two signals in the captured order:
  - **First**: `Val 1`
  - **Second**: `Val 2`
  
This results in the car receiving a legitimate command, as the jamming was bypassed by replaying valid signals.


---

### RollJam Problems

- Many modern cars use different frequencies for **lock** and **unlock**.
- If the attacker only monitors the frequency of the unlock button, they will only be able to unlock the car.
- It requires the legitimate owner to send a legitimate **lock** signal before being able to perform the unlock, given that lock and unlock use the same rolling code.
- **Solutions**: Permanently jam the lock frequency such that the user will need to manually lock the car.

---

### RollBack Attack

- Again, **RollJam** requires the jammer to always be there.
- Although rolling codes have been designed to prevent **replay attacks**, there are still chances that replay might work.
- There may be **synchronization** issues between the key and the car, for which resynchronization is needed.
- Let's exploit this mechanism to evade the security provided by rolling codes.

![[Pasted image 20251016124338.png]]

#### RollJam Attack
1. **Unlock 1**: The owner presses the unlock button, and the signal is captured by the **RollJam device**.
2. **Unlock 2**: The owner presses the unlock button again, but the signal is jamming while the device captures the second unlock signal.
3. **Replay of Unlock 1**: The attacker replays the first captured unlock signal to unlock the car.
4. The attacker can repeat the process, but no further "Unlock" signals can be captured or used after the **Lock** action is pressed by the vehicle.

#### RollBack Attack
1. **Unlock 1**: The attacker jams the signal and captures the first unlock signal.
2. **Unlock 2**: The attacker then jams the signal again while capturing the second unlock signal.
3. Afterward, the vehicle is unlocked, and the attacker can continue to repeat or use the **Unlock n** sequence, bypassing the synchronization requirement for normal key and vehicle communication.
    
---

### RollBack Reconnaissance

- **Attacker's Setup**: The attacker positions the RollBack device near the target car.
- **Victim's Action**: When the victim returns to their car, they attempt to unlock it by sending a signal (`Sendv(Si_unlock)`).
- **RollBack Device's Action**:
  - The device captures the signal.
  - It jams the frequency band to prevent the signal from being received by the car.
- **Victim's Reaction**: The victim assumes poor reception, presses the button again, and sends a new signal (`Sendv(Si+1_unlock)`).
- **RollBack Device's Action**: The RollBack device captures this second signal and allows the car to receive it, leading to the car unlocking. The victim drives away without suspecting any foul play.

---

### RollBack Exploitation

- **Design Vulnerability**: The two captured codes (Si_unlock and Si+1_unlock) are no longer valid after resynchronization.
- **Victim's Actions**: The victim can lock and unlock their car at will, unaware of the vulnerability.
- **Resynchronization**: As resynchronization requires two consecutive valid packets, the attacker can replay the two captured signals to unlock the car, effectively exploiting the system.

---

**Summary**: This highlights a critical flaw in keyless entry systems that rely on rolling codes. The attacker can intercept, jam, and replay the signals without detection, allowing unauthorized access to the vehicle.

---

### One of the Many Implementations
- **AUT64** is an iterated cipher operating on 8-byte blocks.
- In each round, the state is permuted first.
- Then, byte 7 is updated using the round function:
  - $g(a_0, \dots, key_i)$
- **Key_i** is the 32-bit round key.
- The system operates over **12 rounds**.
![[Pasted image 20251016125046.png]]

### Master Problem
- The effective key size of **AUT64** is **91.55 bits**.
- Finding the key through exhaustive search is not practical.
- The key problem is that this **RKE system** uses a **global master key**, independent of the vehicle or remote control.
- This means the same key is stored in millions of **ECUs** and **RKE remotes**, without any diversification of the key.
- The vehicle validates a rolling code by:
  - **Whitelisting certain UIDs**.
  - Checking if the **counter** is within the validity window.

---

### RKE Based on Hitag2 Cipher
- **Hitag2** uses a **48-bit LFSR** and a **non-linear filter function f**.
- In the rolling code scheme, when a button is pressed, the following message is transmitted:

![[Pasted image 20251016130641.png]]

- The **initial state** of the stream cipher consists of:
- The 32-bit **UID** concatenated with the first 16 bits of the key **k**.
- The **ctr** is incremented, and the **initialization vector (iv)** is the **ctr || btn**, which is **XORed** with the last 32 bits of the key and shifted into the LFSR.

### Cipher Description
- The cipher uses a **48-bit Linear Feedback Shift Register (LFSR)** and a **non-linear filter function f**.
- In each **clock cycle**, 20 bits of the LFSR are input into **f** to generate a bit of the keystream.
- The **LFSR** is shifted **one bit to the left**, using the feedback polynomial to generate a new bit on the right.

### Definition 4.1: The feedback function

The feedback function $L : \mathbb{F}_2^{48} \to \mathbb{F}_2$ is defined by:

$$
L(x_0, \dots, x_{47}) := x_0 \oplus x_2 \oplus x_3 \oplus x_6 \oplus x_7 \oplus x_8 \oplus x_{16} \oplus x_{22} \oplus x_{23} \oplus x_{26} \oplus x_{30} \oplus x_{41} \oplus x_{42} \oplus x_{43}
$$
where $\oplus$ denotes the XOR operation.

---
### Definition 4.2: Filter function

The filter function $f : \mathbb{F}_2^{48} \to \mathbb{F}_2$  is defined by:

$$
f(x_0 \dots x_{47}) = f_c(f_a(x_2 x_3 x_5 x_7), f_b(x_{28} x_{29} x_{21} x_{15}), f_b(x_{28} x_{29} x_{21} x_{33}))
$$

where  $f_a : \mathbb{F}_4 \to \mathbb{F}_2$,  $f_b : \mathbb{F}_4 \to \mathbb{F}_2$, and $f_c : \mathbb{F}_2^5 \to \mathbb{F}_2$ are defined as:

$$
f_a(i) = (0xA63C)
$$

$$
f_b(i) = (0xA770)
$$

$$
f_c(i) = (0xD949CB80)
$$

Because $f(x_0 \dots x_{47})$ only depends on $x_2, x_3, x_5 \dots x_{46}$, we define $f_{20} : \mathbb{F}_2^{20} \to \mathbb{F}_2$, writing:

$$
f(x_0 \dots x_{47}) = f_{20}(x_2, x_3, x_5, \dots, x_{46})
$$

### Diagram

Below is the corresponding diagram for the function components:
![[Pasted image 20251016130228.png]]

### Rolling Code on Hitag2

- During the authentication protocol, the internal state of the stream cipher is initialized
- The internal state consists of the 32-bits UID concatenated with the first 16 bits of the key $k$
- The counter $ctr$ is incremented and $iv = ctr \parallel btn$ is XORed with the last 32 bits of the key and shifted into the LFSR
- For this point, the next 32 bits of the keystream (output by the cipher $ks$) are sent as proof of knowledge of the secret $k$

### RKE Based on Hitag2 Cipher

- The next 32 bits of keystream, which are output by the cipher $ks$, are sent as proof of knowledge of the secret key $k$
- $L$ is the feedback function from the LFSR that generates a bit

### Definition 4.4

- Given a key $k = k_0 \cdots k_7 \in F_{2}^{48}$, an identifier $id = id_0 \cdots id_3 \in F_2^{32}$, a counter $ctr \in F_4^{28}$, a button identifier $btn_0 \cdots btn_3 \in F_4$ and keystream $ks = ks_0 \cdots ks_{31} \in F_2^{32}$, we let the initialization vector $iv = ctr \parallel btn$.

- Furthermore, the internal state of the cipher at time $i$ is defined as:
$$
\alpha_i := a_i \parallel a_{i+1} \parallel \cdots \parallel a_{i+7} \in F_48
$$

$$
\begin{aligned}
a_{32+i} &= k_i, &\text{for } i \in [0, 15] \\
a_{48+i} &= k_{16+i} \parallel \alpha_i, &\text{for } i \in [0, 31] \\
a_{80+i} &= L(a_{32+i} \parallel a_{79+i}), &\text{for } i \in [0, 47]
\end{aligned}
$$

- Further, we define the keystream bit $ks_i$ by:

$$
ks_i := f(a_{32+i} \parallel a_{79+i}) \quad \text{for } i \in [0, 31]
$$

Note that the $a_i$ are functions of $k$, $id$, and $btn$. Instead of making this explicit by writing $f(a_{i}, k, id, btn)$, we just write $a_i$ where the $i$ indices depend on the time step.


---

## Correlation Attack on Hitag2

- The purpose of the attacker is to retrieve the key.
- It requires a minimum of four rolling codes, but it would be faster and more precise by having more traces.
- Rolling codes may have an arbitrary counter value, i.e., non-consecutive.
- However, this is good as it increases correlation.
- We denote as <UID, iv, ks>, j = 0,...,n-1, n > 3, n authentication traces.

### Attack Process
1. The adversary first guesses a 16-bit window corresponding to LFSR stream bits $a_{32'}, ..., a_{47'} = k_0, ..., k_{15}$.
2. Together with UID, this gives the adversary $a_0, ..., a_{47}$, which is constant over traces.
3. The adversary computes $b_0 = f(a_0, ..., a_{47})$.
4. The adversary shifts this 16-bit window to the left of the LFSR until bits $a_{32'} .. a_{47'}$ are on the very left of the LFSR, i.e., the point where the cipher starts outputting ks.

#### Formula:
$$
k_s(i) = f(a_{32'+i} \dots a_{79+i}) \quad \text{for} \quad i \in [0,31]
$$


- The adversary computes a correlation score for this guess.
- The window determines 8 input bits $x_0, ..., x_7$ to the filter function $f_{20'}$ while the remaining 12 inputs remain unknown.
- The correlation is taken as the ratio of those $2^{12}$ input values $x_8, ..., x_{19}$ that produce the correct keystream bit $k_{s_0}$.
- Shifting the window further to the left, the adversary can perform tests on multiple keystream bits ($k_{s_0}, ..., k_{s_{15}}$).

### Formula for Single-Bit Correlation Score
$$
\text{bit\_score}(x_0 \dots x_{n-1}, b) = \frac{\#(b = f_{20}(y_0 \dots y_{19}))}{2^{19-n}}
$$
Where $y_0, ..., y_{n-1}$ are the first bits of $x_0 \dots x_{n-1}$ and $n < 20$.

### Formula for Multiple-Bit Correlation Score
$$
\text{score}(x_0 \dots x_{n-1}, k_s0) = \text{bit\_score}(x_0 \dots x_{n-1}, k_s0)
$$
$$
\text{score}(x_0 \dots x_{n-1}, k_s0 \dots k_s(n-1)) = \text{bit\_score}(x_0 \dots x_{n-1}, k_s0) \times \text{score}(x_0 \dots x_{n-2}, k_s(n-1) \dots k_s(n-2))
$$

- The adversary sorts guesses based on their score and stores them in a table, discarding guesses with the lowest score if needed.
- Experiments show that 400,000 guesses are usually sufficient.
- For each guess in the table, the adversary goes back to Step (1) and proceeds as before, except she will now extend the window size by one guessing the next LFSR stream bit ($a_{48}, ..., a_{51}$).
- The power of this attack comes from using the window on the right of the LFSR to compute the necessary keystream bits to correct the internal state.

### Results
- On average, the attack recovers the cryptographic key in approximately 1 minute of computation.
- It requires between 4 and 8 rolling codes.

### Table of Results

| Manufacturer | Model        | Year |
|--------------|--------------|------|
| Alfa Romeo   | Giulietta    | 2010 |
| Chevrolet    | Cruze Hatchback | 2012 |
| Citroen      | Nemo         | 2009 |
| Dacia        | Logan II     | 2012 |
| Fiat         | Punto        | 2016 |
| Ford         | Ka           | 2009, 2016 |
| Lancia       | Delta        | 2009 |
| Mitsubishi   | Colt         | 2004 |
| Nissan       | Micra        | 2006 |
| Opel         | Vectra       | 2008 |
| Opel         | Combo        | 2016 |
| Peugeot      | 207          | 2010 |
| Peugeot      | Boxer        | 2011 |
| Renault      | Clio         | 2011 |
| Renault      | Master       | 2011 |

---

